---
title: "gmse: an R package for generalised management strategy evaluation"
author: "A. Bradley Duthie, Jeremy J. Cusack, Roc&#0237;o Pozo, O. Sarobidy Rakotonarivo, and Nils Bunnefeld"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: gmse.bib
---

```{r, echo = FALSE}
library(GMSE);
plot_gmse_results_vign <- function(res, obs, land, agents, paras, ACTION, COST){
    
    para_vec <- paras[1,]
    
    times <- 1;
    view  <- agents[[1]][1, 9];
    
    land1 <- NULL;
    land3 <- NULL;
    land2 <- land;
    
    for(i in 1:length(land2)){
        land1 <- land2[[i]][,,1];
        land3 <- land2[[i]][,,3];
    }
    
    max_time <- length(res) - 1;
        
    gens <- NULL;
    abun <- NULL;
    est  <- NULL;
    lci  <- NULL;
    uci  <- NULL;
    lnds <- NULL;
    ages <- NULL;
    stky <- NULL;
    land_cols <- c("#F2F2F2FF", "#ECB176FF", "#000000"); 
    cols      <- c("green", "indianred1", "indianred3", "deepskyblue1",
                   "deepskyblue2");
    
    case  <- para_vec[9];
    tiobs <- para_vec[12];
    if(case == 1 & tiobs < 2){
        return("No RMR possible"); 
    }
    mrk <- floor(tiobs / 2);
    rcp <- tiobs - mrk;
    
    max_action <- 0;
    max_cost   <- 0;
    for(i in 1:length(res)){
        act_check <- ACTION[[i]][,8:12,];
        act_check[act_check > 10000] <- -1;
        act_comb <- apply(X = act_check, MARGIN = c(1,2), FUN = sum);
        gen_max_action <- max(act_comb);
        if(gen_max_action > max_action){
            max_action <- gen_max_action;
        }
        cost_check <- COST[[i]][,8:12,];
        cost_check[cost_check >= 10000] <- -1;
        gen_max_cost   <- max(cost_check);
        if(gen_max_cost > max_cost){
            max_cost <- gen_max_cost;
        }
    }
    
    minK <- min(para_vec[6:7]);
    
    ymaxi    <- minK + (minK * (1 + res[[1]][1,10])); # Add for birth rate
    time_max <- length(res);
    for(i in 1:(time_max-1)){
        res_t    <- res[[i]];
        obs_t    <- obs[[i]];
        lnd_t    <- land2[[i]][,,2] * 100;
        age_t    <- agents[[i]];
        if(i > 1){
            res_t <- res_t[res_t[,12] >= para_vec[17],];
        }
        gens  <- c(gens, i);
        abun  <- c(abun, dim(res_t)[1]);
        lnds  <- c(lnds, mean(lnd_t));
        ages  <- rbind(ages, age_t[,16]);
        if(!is.null(obs_t) & case == 1){
            analysis <- chapman_est(observation = obs_t, paras = para_vec);
            est      <- c(est, analysis$Nc);
            lci      <- c(lci, analysis$lci);
            uci      <- c(uci, analysis$uci);
        }
        if(!is.null(obs_t) & !is.null(view) & case == 0){
            analysis <- dens_est(observation = obs_t, paras = para_vec, 
                                 view = view, land = land1);
            est      <- c(est, analysis$Nc);
            lci      <- c(lci, analysis$lci);
            uci      <- c(uci, analysis$uci);
        }
        for(stakeholder in 1:dim(ages)[2]){
            max_yield   <- sum(land3 == stakeholder);
            agent_yield <- rep(x = NA, max_time);
            if(max_yield > 0 & para_vec[104] > 0){
                agent_yield <- 100 * (ages[,stakeholder] / max_yield);
            }
            stky[[stakeholder]] <- agent_yield;
        }
    }
    if(case > 1){
        est <- paras[,100];
    }
    par(mfrow=c(3,2),mar=c(0,0,0,0));
    # ------------- Panel 1 (upper left)
    if(abun[max_time] > 0){
        indis  <- ind_to_land(inds = res_t, land = land1);
        image(indis, col = land_cols, xaxt="n", yaxt="n");
    }else{
        image(land1, col = land_cols, xaxt="n", yaxt="n");
    }
    # ------------- Panel 2 (upper right)
    col_num <- max(land3);
    image(land3, col = topo.colors(col_num), xaxt="n", yaxt="n");
    # ------------- Panel 3 (middle left)
    par(mar = c(4, 5, 1, 5));
    plot(x = gens, y = abun, pch = 20, type="l", lwd = 2, ylim = c(0, ymaxi),
         xlim=c(0, time_max), xlab = "Time Step", ylab = "Abundance",
         cex.lab=1.25);
    if(case == 0 | case == 1){
        polygon(y = c(lci,rev(uci)), x = c(gens, rev(gens)), border = NA,
                col="lightblue");
        points(x = gens, y = est, pch = 20, type = "l", lwd = 2, col = "cyan4");
    }else{
        points(x = gens, y = est[-time_max], pch = 20, type = "l", lwd = 2, 
               col = "cyan4");
    }
    abline(h = para_vec[7], col = "red", lwd = 0.8, lty = "dashed");
    abline(h = ACTION[[1]][1,5,1], col = topo.colors(1), lwd = 0.8, 
           lty = "dashed");
    points(x = gens, y = abun, pch = 20, type = "l", lwd = 3, col = "black");
    par(new = TRUE);
    plot(x = gens, y = lnds, pch = 20, type = "l", lwd = 3, col = "orange", 
         xlab = "", xlim = c(0, time_max), ylim = c(0, 100), xaxt="n", yaxt="n", 
         ylab = "");
    axis(side = 4, at = c(0, 25, 50, 75, 100));
    mtext("Mean % Yield", side = 4, line = 2.4);
    # ------------ Panel 4 (middle right);
    par(mar = c(4, 4.5, 1, 1));
    cell_number <- dim(land3)[1] * dim(land3)[2];
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, ylim = c(0, 100),
         xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "Stake-holder % yield", cex.lab = 1.25);
    stake_colors <- topo.colors( dim(age_t)[1] );
    if(para_vec[104] > 0){
        for(stakeholder in 1:dim(ages)[2]){
            points(x = gens, y = stky[[stakeholder]], type="l", lwd=2, 
                   col = stake_colors[stakeholder]);
        }
    }
    # ------------- Panel 5 (lower left)
    res_costs <- matrix(data = 0, nrow = max_time, ncol = 5);
    for(j in 1:max_time){
        res_costs[j,1] <- ACTION[[j]][3,8,1];
        res_costs[j,2] <- ACTION[[j]][3,9,1];
        res_costs[j,3] <- ACTION[[j]][3,10,1];
        res_costs[j,4] <- ACTION[[j]][3,11,1];
        res_costs[j,5] <- ACTION[[j]][3,12,1];
    }
    par(mar = c(4, 5, 1, 5.5), xpd = TRUE);
    y_upper_limit <- max_cost + (0.25 * max_cost);
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, 
         ylim = c(0, y_upper_limit), xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "Cost of actions", cex.lab = 1.25);
    if(para_vec[89] == 1){
        points(x = gens, y = res_costs[,1], type = "l", col = cols[1], lwd = 2);
    }
    if(para_vec[90] == 1){
        points(x = gens, y = res_costs[,2], type = "l", col = cols[2], lwd = 2);
    }
    if(para_vec[91] == 1){
        points(x = gens, y = res_costs[,3], type = "l", col = cols[3], lwd = 2);
    }
    if(para_vec[92] == 1){
        points(x = gens, y = res_costs[,4], type = "l", col = cols[4], lwd = 2);
    }
    if(para_vec[93] == 1){
        points(x = gens, y = res_costs[,5], type = "l", col = cols[5], lwd = 2);
    }
    legend(x = time_max + (time_max * 0.02), y = y_upper_limit, 
           fill = c(cols[1:5], "purple", "orange"), horiz = FALSE,
           legend = c("scaring", "culling", "castration", "feeding", 
                      "helping", "tend crop", "kill crop"), bty = "n");
    par(xpd = FALSE);
    # ------------- Panel 6 (lower right)
    res_acts <- matrix(data = 0, nrow = time_max, ncol = 7);
    gens     <- 1:time_max;
    for(j in 1:time_max){
        for(k in 2:dim(ACTION[[j]])[3]){
            res_acts[j,1] <- res_acts[j,1] + ACTION[[j]][1,8,k] - para_vec[96];
            res_acts[j,2] <- res_acts[j,2] + ACTION[[j]][1,9,k] - para_vec[96];
            res_acts[j,3] <- res_acts[j,3] + ACTION[[j]][1,10,k]- para_vec[96];
            res_acts[j,4] <- res_acts[j,4] + ACTION[[j]][1,11,k]- para_vec[96];
            res_acts[j,5] <- res_acts[j,5] + ACTION[[j]][1,12,k]- para_vec[96];
            res_acts[j,6] <- res_acts[j,6] + ACTION[[j]][2,10,k]- para_vec[96];
            res_acts[j,7] <- res_acts[j,7] + ACTION[[j]][2,11,k]- para_vec[96];
        }
    }
    par(mar=c(4, 4.5, 1, 1));
    y_upper_limit <- max_action + (0.25 * max_action);
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, 
         ylim = c(0, y_upper_limit), xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "Actions made", cex.lab = 1.25);
    if(para_vec[89] == 1){
        points(x = gens, y = res_acts[,1], type = "l", col = cols[1], lwd = 2);
    }
    if(para_vec[90] == 1){
        points(x = gens, y = res_acts[,2], type = "l", col = cols[2], lwd = 2);
    }
    if(para_vec[91] == 1){
        points(x = gens, y = res_acts[,3], type = "l", col = cols[3], lwd=2);
    }
    if(para_vec[92] == 1){
        points(x=gens, y=res_acts[,4], type="l", col=cols[4], lwd=2);
    }
    if(para_vec[93] == 1){
        points(x = gens, y = res_acts[,5], type = "l", col = cols[5], lwd = 2);
    }
    if(para_vec[94] == 1){
        points(x = gens, y = res_acts[,6], type = "l", lty = "solid", 
               col = "purple", lwd = 3);
    }
    if(para_vec[95] == 1){
        points(x = gens, y = res_acts[,7], type = "l", lty = "solid", 
               col = "orange", lwd = 3);
    }
}
```

# Introduction

Management of 

- Broad paragraph about managing populations and conservation given uncertainty and conflict among stakeholders.

- Paragraph introducing adaptive management, then management strategy evaluation framework [@Bunnefeld2011]; introduce this *generalised* management strategy evaluation framework and R package as filling an important gap in tools available for modelling mangement.

- More details about what types of problems *GMSE* was developed to solve and (very generally) how it can solve them through individual-based modelling and a game-theoretic approach that uses genetic algorithms to simulate manager and stakeholder decision making.

# GMSE model structure

Introduce the general mode of generalised management strategy evaluation (e.g., below), and the idea of simulating the package simulating the whole process of management.

********************************************************************************

```{r, echo = FALSE, fig.height = 4, fig.width = 4, fig.align = 'left', fig.cap = "**Figure 1:** *Description of the generalised management strategy evaluation framework*"}
mbox <- function(x0, x1, y0, y1){
    xx <- seq(from=x0, to=x1, length.out = 100);
    yy <- seq(from=y0, to=y1, length.out = 100);
    xd <- c(rep(x0, 100), xx, rep(x1,100), rev(xx));
    yd <- c(yy, rep(y1,100), rev(yy), rep(y0, 100));
    return(list(x=xd, y=yd));
}
par(mar=c(0,0,0,0));
plot(x = 0, y = 0, type = "n", xlim = c(0, 100), ylim = c(0, 100), 
     xaxt = "n", yaxt = "n", xlab = "", ylab = "");
# Manager model 
manger_model_box <- mbox(x0 = 1, x1 = 30, y0 = 70, y1 = 99);
polygon(x = manger_model_box$x, y = manger_model_box$y, lwd = 3);
text(x = 15, y = 90, cex = 1.0, labels = "Manager");
text(x = 15, y = 83, cex = 1.0, labels = "model");
# User model
user_model_box <- mbox(x0 = 70, x1 = 99, y0 = 70, y1 = 99);
polygon(x = user_model_box$x, y = user_model_box$y, lwd = 3);
text(x = 85, y = 90, cex = 1.0, labels = "User");
text(x = 85, y = 83, cex = 1.0, labels = "model");
# Observation model
observe_model_box <- mbox(x0 = 1, x1 = 30, y0 = 1, y1 = 30);
polygon(x = observe_model_box$x, y = observe_model_box$y, lwd = 3);
text(x = 15, y = 23, cex = 1.0, labels = "Observation");
text(x = 15, y = 15, cex = 1.0, labels = "model");
# Resource model
resource_model_box <- mbox(x0 = 70, x1 = 99, y0 = 1, y1 = 30);
polygon(x = resource_model_box$x, y = resource_model_box$y, lwd = 3);
text(x = 85, y = 23, cex = 1.0, labels = "Natural");
text(x = 85, y = 15, cex = 1.0, labels = "resources");
text(x = 85, y = 7,  cex = 1.0, labels = "model");
# Game-theoretic (genetic algorithm) model
game_model_box <- mbox(x0 = 36, x1 = 65, y0 = 36, y1 = 65);
polygon(x = game_model_box$x, y = game_model_box$y, lwd = 3);
text(x=50, y=55, labels="Genetic", cex=1.0);
text(x=50, y=48, labels="algorithm", cex=1.0);
# Arrows indicating direction of GMSE model
arrows(x0=15, x1=15, y0=30, y1=70, lwd=2, length=0.15);
arrows(x0=30, x1=70, y0=85, y1=85, lwd=2, length=0.15);
arrows(x0=85, x1=85, y0=70, y1=30, lwd=2, length=0.15);
arrows(x0=70, x1=30, y0=15, y1=15, lwd=2, length=0.15);
arrows(x0=30, x1=36, y0=70, y1=65, lwd=2, length=0.075, code=3);
arrows(x0=65, x1=70, y0=65, y1=70, lwd=2, length=0.075, code=3);
text(x=50, y=90, labels="Policy", cex = 1.0);
text(x=50, y=20, labels="Monitoring", cex = 1.0);
text(x=10, y=48, labels="Indicators", srt=90, cex = 1.0);
text(x=90, y=52, labels="Off-take", srt=-90, cex = 1.0);
```

********************************************************************************

Next there will be some general explanation of what it is that each sub-model does. The subfunction called in R will be mentioned, but with emphasis that the software user need not do this themselves. I will emphasise that each model can be built upon as desired to include more (or less) detail.

## Natural resource model

- Explanation of what's going on in the natural resource model
- Individual-based
- Spatially explicit
- Models processes of birth, movement, interaction with landscape, and death, with simulated carrying capacities on birth or death. Note that the individual-based nature of the model naturally gives rise to some stochasticity.

## Observation model

- Explanation of what's going on in the observation model (manager does some observing)
- Also individual based in the sense that the manager is an individual doing work
- Four different types of observation are permitted
    1. Density-based observation
    2. Mark-recapture based observation
    3. Linear transect based observation
    4. Blocked transect based observation
- Note that the observation model mimics the sampling of resources (i.e., data collection), but not data analysis.
- Uncertainty in the observation model is created naturally by imposed sampling limitations and resource movement during sampling

## Manager model

- Explanation of what's going on in the manager model (analysing observations and setting policy)
- Manager analyses data from one of the four observation models used, then estimates the resource abundance
- Manager compares the estimated resource abundance with the target abundance, then uses the difference between the estimate and the target to develop a policy
- Policy is developed by calling the genetic algorithm, which takes in parameters governing the manager's constraints on developing policy, the options of policy available for the manager to set (e.g., culling, scaring, etc.), and user actions from the previous time step to predict the consequences of the policy
- The genetic algorithm finds an adaptive solution that is predicted to move the resource population abundance to its target
- The new policy is set for all stakeholders in the user model

## User model

- Explanation of what's going on in the user model (users respond to policy with actions affecting resources and landscape)
- Users take the new policy and then respond to it by attempting to maximise their utilities for resource abundance and landscape yield
- Each user individually calls the genetic algorithm, which takes in parameters governing constraints on user actions and options of actions available to the user (e.g., culling, scaring, etc.) to predict the consequences of the user's actions on their own utility
- The genetic finds an adaptive solution for each stakeholder
- The resource and landscape are affected by the stakeholders taking actions

## Genetic Algorithm

Game theory is the standard tool for understanding conflict bewteen rational agents, and is therefore the appropriate tool for modelling manager and stakeholder actions and to address issues of cooperation and conflict in conservation [@Colyvan2011; @Lee2012; @Kark2015; @Adami2016; @Tilman2016]. A game-theoretic approach is entirely compatible with agent-based modelling [@An2012, @Tesfatsion2017]. When modelled strategies are complex, machine learning techniques such as the use of genetic algorithms can be used to find adaptive strategies for games [e.g., @Balmann2000; @Tu2000; @Hamblin2013]. In keeping with the MSE approach [@Bunnefeld2011], GMSE does not attempt to find optimal strategies or solutions for managers or stakeholders. Instead, a genetic algorithm is used to find manager and stakeholder strategies that are well-adapted to achieving agent goals.


- Brief introduction to the use of genetic algorithms, and the goal of using one in GMSE
- Explain that the genetic algorithm is called in both the manager and user models to find strategic solutions to particular scenarios
- Further explain that each agent (stakeholder or manager) is constrained to certain costs in allocating their actions or policy

## Model output

- List all of the output that the model is capable of producing -- i.e., all of the data from each model over all time steps
- Explain that plots show the movement of resource, land allocation, resource population dynamics and population estimates, crop yield on a landscape, manager policy, and stakeholder actions

# An example of crop management

Here we consider the example of a managed natural resources whose abundance affects a group of stakeholders by temporarily decreasing the value of stakeholder land. This scenario could be interpreted in multiple ways, such as a protected population of waterfowl that exploits agricultural lands causing a conservation conflict with farmers [e.g., @Tuvendal2015; @Fox2017a; @Fox2016a]. Managers in this example might want to keep the abundance of waterfowl at a target level, while farmers might want to minimise the damage to their crops inflicted by waterfowl. Using GMSE, we can simulate the dynamics of waterfowl, along with the continued monitoring and policy setting by managers, and the actions that farmers take to protect their crop yields given the constraints of policy. All parameter values for this simulation can be set with the `gmse()` function. Here we consider a population of waterfowl with an initial abundance and manager target abundance of 1000, but whose carrying capacity (applied to mortality) is 2000. These waterfowl will consume and destroy all crop yield upon arrival to a landscape cell. Managers estimate population size in each time step using mark-recapture techniques, and use their estimates to set costs of culling and scaring waterfowl (i.e., 'policy') for ten farmers. Farmers attempt to reduce the negative impact of waterfowl on the cropland that they own, working within the constraints of culling and scaring costs and their budget for performing these actions.

```{r, echo = TRUE}
sim <- gmse(land_ownership = TRUE, stakeholders = 10, observe_type = 1, 
            res_death_K = 2000, manage_target = 1000, RESOURCE_ini = 1000, 
            user_budget = 5000, manager_budget = 5000, res_consume = 1, 
            scaring = TRUE, fixed_mark = 50, fixed_recapt = 300, 
            plotting = FALSE);
```

Parameters in `gmse()` not listed are set to default values. By plotting the output with `plot_gmse_results`, simulation results can be interpreted visually.

********************************************************************************

```{r, echo = FALSE, fig.width = 7, fig.height = 8, fig.align = 'left', fig.cap = "**Figure 2:** *Results of an example simulation illustrating the management of a protected resource that exploits the land of 10 stakeholders. The upper left panel shows locations of resources (black dots) on the landscape in the final time step of the simulation. The upper right panel shows the same landscape broken down into 10 differently coloured regions, which correspond to areas of land owned by each of the 10 stakeholders. The middle left panel shows the actual abundance of resources (black solid line, and the abundance of resources as estimated by the manager (blue solid line; shading indicates 95 percent confidence intervals of a mark-recapture analysis), over time. The horizontal dotted red line shows the resource carrying capacity enacted on adult mortality, and the horizontal dotted blue line shows the manager's target for resource abundance. The orange line shows the total percent yield of landscape cells. The middle right panel shows total percent yield of landscape cells for each individual farmer, differentiated by colour, where line colours correspond to areas of the landscape in the upper right panel. The lower left panel shows the cost of stakeholder performing actions over time, as set by the manager. The lower right panel shows the total number of actions attempted to be performed by all stakeholders over time (some actions might be unncessful if resources are unavailable on a stakeholder's land to cull or scare, so, e.g., culling actions might be larger than resources actually culled).*"}
plot_gmse_results_vign(res = sim$resource, obs = sim$observation, 
                       land = sim$land, agents = sim$agents, paras = sim$paras,
                       ACTION = sim$action, COST = sim$cost);
```

********************************************************************************

Figure 2 shows the landscape broken down by resource position and stakeholder ownership in the upper left and right hand panels, respectively. The waterfowl population fluctuates around the manager's target size of 1000, but the manager's estimate of population size deviates from its actual size due to uncertainty caused by the observation process (compare black and blue lines the middle left panel). Because the waterfowl have a direct negative effect on landscape yield, total landscape yield (orange line of the middle left panel), along with the yield of individual farmers (right middle panel), is low when waterfowl abundance is high, and vice versa.

Only the estimates of population size from the observation model are available to the manager, so policy change at any time step is driven primarily by the deviation of the currently estimated population size from the manager's target and the actions of farmers in the previous time step. Hence, when the population size is estimated to be below (above) the manager's target, the manager increases (decreases) the cost of culling and decreases (increases) the cost of scaring. Farmers are interested only in mitigating waterfowl's exploitation of their crops, so they will either cull or scare to remove the waterfowl from their land, depending on which ever option is cheaper.



# Summary

# References

















