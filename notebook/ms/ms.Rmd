---
title: 'GMSE: an R package for generalised management strategy evaluation'
author: A. Bradley Duthie, Jeremy J. Cusack, Roc&#0237;o Pozo, O. Sarobidy Rakotonarivo,
  and Nils Bunnefeld
date: '`r Sys.Date()`'
output:
  html_document: default
  pdf_document:
    fig_caption: yes
  word_document:
    fig_caption: yes
    reference_docx: docx_template.docx
linestretch: 1
header-includes:
- \usepackage{natbib}
- \usepackage{lineno}
- \linenumbers
- \bibliographystyle{amnatnat}
bibliography: gmse.bib
---

******************************


```{r, echo = FALSE}
library(GMSE);
plot_gmse_results_vign <- function(res, obs, land, agents, paras, ACTION, COST){
    
    para_vec <- paras[1,]
    
    times <- 1;
    view  <- agents[[1]][1, 9];
    
    land1 <- NULL;
    land3 <- NULL;
    land2 <- land;
    
    for(i in 1:length(land2)){
        land1 <- land2[[i]][,,1];
        land3 <- land2[[i]][,,3];
    }
    
    max_time <- length(res) - 1;
        
    gens <- NULL;
    abun <- NULL;
    est  <- NULL;
    lci  <- NULL;
    uci  <- NULL;
    lnds <- NULL;
    ages <- NULL;
    stky <- NULL;
    land_cols <- c("#F2F2F2FF", "#ECB176FF", "#000000"); 
    cols      <- c("green", "indianred1", "indianred3", "deepskyblue1",
                   "deepskyblue2");
    
    case  <- para_vec[9];
    tiobs <- para_vec[12];
    if(case == 1 & tiobs < 2){
        return("No RMR possible"); 
    }
    mrk <- floor(tiobs / 2);
    rcp <- tiobs - mrk;
    
    max_action <- 0;
    max_cost   <- 0;
    for(i in 1:length(res)){
        act_check <- ACTION[[i]][,8:12,];
        act_check[act_check > 10000] <- -1;
        act_comb <- apply(X = act_check, MARGIN = c(1,2), FUN = sum);
        gen_max_action <- max(act_comb);
        if(gen_max_action > max_action){
            max_action <- gen_max_action;
        }
        cost_check <- COST[[i]][,8:12,];
        cost_check[cost_check >= 10000] <- -1;
        gen_max_cost   <- max(cost_check);
        if(gen_max_cost > max_cost){
            max_cost <- gen_max_cost;
        }
    }

    minK <- min(para_vec[6:7]);
    
    ymaxi    <- minK + (minK * (1 + res[[1]][1,10])); # Add for birth rate
    time_max <- length(res);
    for(i in 1:(time_max-1)){
        res_t    <- res[[i]];
        obs_t    <- obs[[i]];
        lnd_t    <- land2[[i]][,,2] * 100;
        age_t    <- agents[[i]];
        if(i > 1){
            res_t <- res_t[res_t[,12] >= para_vec[17],];
        }
        gens  <- c(gens, i);
        abun  <- c(abun, dim(res_t)[1]);
        lnds  <- c(lnds, mean(lnd_t));
        ages  <- rbind(ages, age_t[,16]);
        if(!is.null(obs_t) & case == 1){
            analysis <- chapman_est(observation = obs_t, paras = para_vec);
            est      <- c(est, analysis$Nc);
            lci      <- c(lci, analysis$lci);
            uci      <- c(uci, analysis$uci);
        }
        if(!is.null(obs_t) & !is.null(view) & case == 0){
            analysis <- dens_est(observation = obs_t, paras = para_vec, 
                                 view = view, land = land1);
            est      <- c(est, analysis$Nc);
            lci      <- c(lci, analysis$lci);
            uci      <- c(uci, analysis$uci);
        }
        for(stakeholder in 1:dim(ages)[2]){
            max_yield   <- sum(land3 == stakeholder);
            agent_yield <- rep(x = NA, max_time);
            if(max_yield > 0 & para_vec[104] > 0){
                agent_yield <- 100 * (ages[,stakeholder] / max_yield);
            }
            stky[[stakeholder]] <- agent_yield;
        }
    }
    if(case > 1){
        est <- paras[,100];
    }
    par(mfrow=c(3,2),mar=c(0,0,0,0));
    # ------------- Panel 1 (upper left)
    if(abun[max_time] > 0){
        indis  <- ind_to_land(inds = res_t, land = land1);
        image(indis, col = land_cols, xaxt="n", yaxt="n");
    }else{
        image(land1, col = land_cols, xaxt="n", yaxt="n");
    }
    # ------------- Panel 2 (upper right)
    col_num <- max(land3);
    image(land3, col = topo.colors(col_num), xaxt="n", yaxt="n");
    # ------------- Panel 3 (middle left)
    par(mar = c(4, 5, 1, 5));
    plot(x = gens, y = abun, pch = 20, type="l", lwd = 2, ylim = c(0, ymaxi),
         xlim=c(0, time_max), xlab = "Time Step", ylab = "Abundance",
         cex.lab=1.25);
    if(case == 0 | case == 1){
        polygon(y = c(lci,rev(uci)), x = c(gens, rev(gens)), border = NA,
                col="lightblue");
        points(x = gens, y = est, pch = 20, type = "l", lwd = 2, col = "cyan4");
    }else{
        points(x = gens, y = est[-time_max], pch = 20, type = "l", lwd = 2, 
               col = "cyan4");
    }
    abline(h = para_vec[7], col = "red", lwd = 0.8, lty = "dashed");
    abline(h = ACTION[[1]][1,5,1], col = topo.colors(1), lwd = 0.8, 
           lty = "dashed");
    points(x = gens, y = abun, pch = 20, type = "l", lwd = 3, col = "black");
    par(new = TRUE);
    plot(x = gens, y = lnds, pch = 20, type = "l", lwd = 3, col = "orange", 
         xlab = "", xlim = c(0, time_max), ylim = c(0, 100), xaxt="n", yaxt="n", 
         ylab = "");
    axis(side = 4, at = c(0, 25, 50, 75, 100));
    mtext("Mean % Yield", side = 4, line = 2.4);
    # ------------ Panel 4 (middle right);
    par(mar = c(4, 4.5, 1, 1));
    cell_number <- dim(land3)[1] * dim(land3)[2];
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, ylim = c(0, 100),
         xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "stakeholder % yield", cex.lab = 1.25);
    stake_colors <- topo.colors( dim(age_t)[1] );
    if(para_vec[104] > 0){
        for(stakeholder in 1:dim(ages)[2]){
            points(x = gens, y = stky[[stakeholder]], type="l", lwd=2, 
                   col = stake_colors[stakeholder]);
        }
    }
    # ------------- Panel 5 (lower left)
    res_costs <- matrix(data = 0, nrow = max_time, ncol = 5);
    for(j in 1:max_time){
        res_costs[j,1] <- ACTION[[j]][3,8,1];
        res_costs[j,2] <- ACTION[[j]][3,9,1];
        res_costs[j,3] <- ACTION[[j]][3,10,1];
        res_costs[j,4] <- ACTION[[j]][3,11,1];
        res_costs[j,5] <- ACTION[[j]][3,12,1];
    }
    par(mar = c(4, 5, 1, 5.5), xpd = TRUE);
    y_upper_limit <- max_cost + (0.25 * max_cost);
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, 
         ylim = c(0, y_upper_limit), xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "Cost of actions", cex.lab = 1.25);
    if(para_vec[89] == 1){
        points(x = gens, y = res_costs[,1], type = "l", col = cols[1], lwd = 2);
    }
    if(para_vec[90] == 1){
        points(x = gens, y = res_costs[,2], type = "l", col = cols[2], lwd = 2);
    }
    if(para_vec[91] == 1){
        points(x = gens, y = res_costs[,3], type = "l", col = cols[3], lwd = 2);
    }
    if(para_vec[92] == 1){
        points(x = gens, y = res_costs[,4], type = "l", col = cols[4], lwd = 2);
    }
    if(para_vec[93] == 1){
        points(x = gens, y = res_costs[,5], type = "l", col = cols[5], lwd = 2);
    }
    legend(x = time_max + (time_max * 0.02), y = y_upper_limit, 
           fill = c(cols[1:5], "purple", "orange"), horiz = FALSE,
           legend = c("scaring", "culling", "castration", "feeding", 
                      "helping", "tend crop", "kill crop"), bty = "n");
    par(xpd = FALSE);
    # ------------- Panel 6 (lower right)
    res_acts <- matrix(data = 0, nrow = time_max, ncol = 7);
    gens     <- 1:time_max;
    for(j in 1:time_max){
        for(k in 2:dim(ACTION[[j]])[3]){
            res_acts[j,1] <- res_acts[j,1] + ACTION[[j]][1,8,k] - para_vec[96];
            res_acts[j,2] <- res_acts[j,2] + ACTION[[j]][1,9,k] - para_vec[96];
            res_acts[j,3] <- res_acts[j,3] + ACTION[[j]][1,10,k]- para_vec[96];
            res_acts[j,4] <- res_acts[j,4] + ACTION[[j]][1,11,k]- para_vec[96];
            res_acts[j,5] <- res_acts[j,5] + ACTION[[j]][1,12,k]- para_vec[96];
            res_acts[j,6] <- res_acts[j,6] + ACTION[[j]][2,10,k]- para_vec[96];
            res_acts[j,7] <- res_acts[j,7] + ACTION[[j]][2,11,k]- para_vec[96];
        }
    }
    par(mar=c(4, 4.5, 1, 1));
    y_upper_limit <- max_action + (0.25 * max_action);
    plot(x = gens, y = gens, pch = 20, type = "n", lwd = 2, 
         ylim = c(0, y_upper_limit), xlim = c(0, time_max), xlab = "Time Step", 
         ylab = "Actions made", cex.lab = 1.25);
    if(para_vec[89] == 1){
        points(x = gens, y = res_acts[,1], type = "l", col = cols[1], lwd = 2);
    }
    if(para_vec[90] == 1){
        points(x = gens, y = res_acts[,2], type = "l", col = cols[2], lwd = 2);
    }
    if(para_vec[91] == 1){
        points(x = gens, y = res_acts[,3], type = "l", col = cols[3], lwd=2);
    }
    if(para_vec[92] == 1){
        points(x=gens, y=res_acts[,4], type="l", col=cols[4], lwd=2);
    }
    if(para_vec[93] == 1){
        points(x = gens, y = res_acts[,5], type = "l", col = cols[5], lwd = 2);
    }
    if(para_vec[94] == 1){
        points(x = gens, y = res_acts[,6], type = "l", lty = "solid", 
               col = "purple", lwd = 3);
    }
    if(para_vec[95] == 1){
        points(x = gens, y = res_acts[,7], type = "l", lty = "solid", 
               col = "orange", lwd = 3);
    }
}
```


Abstract
===================================================

1. Management strategy evaluation (MSE) is a powerful tool for simulating all key aspects of natural resource management under conditions of uncertainty.
2. We present the R package GMSE, which generalises MSE using a game-theoretic approach to simulate adaptive decision-making management scenarios between stakeholders with competing objectives under complex social-ecological interactions and uncertainty.
3. GMSE is agent-based and spatially explicit, and incorporates a high degree of realism through mechanistic modelling of links and feedbacks among stakeholders and with the ecosystem.
4. We show how GMSE simulates a social-ecological system using the example of a waterfowl population in an agricultural landscape that is adaptively managed; simulated waterfowl exploit agricultural land, causing conflict between conservation interests and the interest of food producers maximising their crop yield.
5. The R package GMSE is open source under GNU Public License; source code and documents are freely available on GitHub.

Introduction
===================================================

Many global natural resources, including the biodiversity on which critical ecosystem services depend, are in a state of severe decline [@Dirzo2014; @Hautier2015; @Ceballos2017; @OConnell2017]. Conservation of biodiversity can be complicated by the immediate need to use natural resources and land area for human livelihood (e.g., food production), causing real or perceived conflicts between conservation and food security and creating a challenge for the management of many natural resources [@Redpath2015a]. Given an increasing human population [@Crist2017], the number and intensity of such conflicts are likely to increase into the twenty first century. Effective management tools are therefore needed for the long-term maintenance of natural resources under the rising demand for food production [@Fischer2017].

To effectively manage natural resources, an adaptive approach allows managers to iteratively update their models of resource dynamics and respond flexibly to changing conditions [@Keith2011]. This approach is especially effective when considering all aspects of the social-ecological system being managed, including the dynamics of resources, monitoring, and the decision-making processes of stakeholders [@Bunnefeld2011; @Bunnefeld2014]. Management strategy evaluation (MSE) is a modelling framework, first developed in fisheries, for simulating all of these aspects of resource management in a way that uniquely considers the uncertainties inherent to every stage of the management process [@Bunnefeld2011; @Punt2016]. Nevertheless, MSE remains limited in its ability to model human decision-making [@Fulton2011a; @Dichmont2017]; manager decisions are typically based on fixed rules, and user behaviour likewise remains fixed over time instead of dynamically responding to changing resource availability and management decisions [@Schluter2012; @Melbourne-Thomas2017]. Here we introduce generalised management strategy evaluation (GMSE), which incorporates a game-theoretic perspective to model the goal-oriented, dynamic decision-making processes of stakeholders. 

The GMSE R package is a flexible, highly mechanistic, agent-based modelling tool to simulate all key aspects of natural resource management. GMSE considers a range of parameters to simulate resource dynamics and management policy options, and uses genetic algorithms to dynamically model stakeholder (manager and user) decision-making. Genetic algorithms find adaptive solutions to any simulated conditions given stakeholder-specific goals, allowing GMSE to model scenarios of conservation conflict. 

GMSE allows researchers to address adaptive management questions *in silico* through simulation. Simulations can be parameterised with initial conditions derived from empirical populations of conservation interest to predict key social-ecological outcomes (e.g., resource extinction, agricultural yield) given uncertainty. The sensitivity of these outcomes to different management options (e.g., population target, policies available, observation methods, budget constraints, etc.) can thereby inform management decisions, even given competing management objectives caused by conservation conflict [e.g., @Strand2012; @Redpath2013; @Sundt-Hansen2015; @Pozo2017; @Fox2017a].  Additionally, GMSE can be used to explore general questions concerning management theory such as the following: How is population persistence affected by management frequency or observation intensity? How does variation in user actions affect the distribution of resources or landscape properties? How do asymmetries in stakeholder influence (i.e., budgets) affect resource dynamics?


GMSE model structure
===================================================

GMSE builds off of the MSE framework, which includes four sub-models, each of which runs once in a single time step of the broader model (Figure 1). (1) A population of discrete resources with individual traits (e.g., location, age) is modelled on a spatially-explicit landscape and can simulate resource birth, movement, interaction with the landscape, and death; the discrete nature of resources causes demographic stochasticity, and therefore uncertainty. This sub-model is unique in not relying on other sub-models because ecological dynamics can be simulated in the absence of observation and management. (2) Observation is modelled in one of four ways: resource counting on a subset of landscape cells [e.g., @Nuno2013], marking and recapturing a fixed number of resources, and resource counting on the whole landscape either one linear transect or one rectangular block at a time (during which resources might move). Sampling error from all of these mechanisms of observation generates a range of uncertainties depending on monitoring effort. (3) Managers analyse data collected from observations to estimate resource abundance, then compare this estimate with their target abundance. Policy is developed by calling the genetic algorithm (see below), which works within a manager's constraints to find costs for user actions on the resource (e.g., culling, scaring, etc.) that minimise deviation from the target abundance, as informed by the predicted consequences of each action on resource abundance and user action histories. After a suitable policy is found, (4) users can perform actions that affect resources or landscape cells. Users respond to policy individually, each calling the genetic algorithm to find actions that maximise their own utilities (e.g., maximise resource use or landscape yield) within their imposed constraints. Once each user has found an adaptive strategy, user actions affect resources and landscape cells, feeding back into the resource sub-model.

```{r, echo = FALSE, fig.height = 4, fig.width = 4, fig.align = 'left', fig.cap = "Description of one time step of the generalised management strategy evaluation framework, which is comprised of four separate sub-models."}
mbox <- function(x0, x1, y0, y1){
    xx <- seq(from=x0, to=x1, length.out = 100);
    yy <- seq(from=y0, to=y1, length.out = 100);
    xd <- c(rep(x0, 100), xx, rep(x1,100), rev(xx));
    yd <- c(yy, rep(y1,100), rev(yy), rep(y0, 100));
    return(list(x=xd, y=yd));
}
par(mar=c(0,0,0,0));
plot(x = 0, y = 0, type = "n", xlim = c(0, 100), ylim = c(0, 100), 
     xaxt = "n", yaxt = "n", xlab = "", ylab = "");
# Manager model 
manger_model_box <- mbox(x0 = 1, x1 = 30, y0 = 70, y1 = 99);
polygon(x = manger_model_box$x, y = manger_model_box$y, lwd = 3);
text(x = 15, y = 90, cex = 1.0, labels = "Manager");
text(x = 15, y = 83, cex = 1.0, labels = "model");
text(x = 5, y = 73, labels="(3)");
# User model
user_model_box <- mbox(x0 = 70, x1 = 99, y0 = 70, y1 = 99);
polygon(x = user_model_box$x, y = user_model_box$y, lwd = 3);
text(x = 85, y = 90, cex = 1.0, labels = "User");
text(x = 85, y = 83, cex = 1.0, labels = "model");
text(x = 74, y = 73, labels="(4)");
# Observation model
observe_model_box <- mbox(x0 = 1, x1 = 30, y0 = 1, y1 = 30);
polygon(x = observe_model_box$x, y = observe_model_box$y, lwd = 3);
text(x = 15, y = 23, cex = 1.0, labels = "Observation");
text(x = 15, y = 15, cex = 1.0, labels = "model");
text(x = 5, y = 4, labels="(2)");
# Resource model
resource_model_box <- mbox(x0 = 70, x1 = 99, y0 = 1, y1 = 30);
polygon(x = resource_model_box$x, y = resource_model_box$y, lwd = 3);
text(x = 85, y = 23, cex = 1.0, labels = "Natural");
text(x = 85, y = 15, cex = 1.0, labels = "resources");
text(x = 85, y = 7,  cex = 1.0, labels = "model");
text(x = 74, y = 4, labels="(1)");
# Game-theoretic (genetic algorithm) model
game_model_box <- mbox(x0 = 36, x1 = 65, y0 = 36, y1 = 65);
polygon(x = game_model_box$x, y = game_model_box$y, lwd = 3);
text(x=50, y=58, labels="Genetic", cex=1.0);
text(x=50, y=51, labels="algorithm", cex=1.0);
sc1 <- seq(from = 0, to = pi, by = 0.001);
sc2 <- seq(from = pi, to = 2*pi, by = 0.001);
points(x = 2*cos(sc1) + 41, y = 42 + 2*sin(sc1), lwd = 1.5, type = "l");
points(x = 2*cos(sc2) + 41, y = 40 + 2*sin(sc2), lwd = 1.5, type = "l");
arrows(x0 = 43, x1 = 43, y0 = 42, y1 = 41, lwd = 1.5, length = 0.06);
arrows(x0 = 39, x1 = 39, y0 = 40, y1 = 41, lwd = 1.5, length = 0.06);
text(x=43, y=42, labels="Multiple", cex=0.7, pos = 4);
text(x=43, y=39, labels="Generations", cex=0.7, pos = 4);
# Arrows indicating direction of GMSE model
arrows(x0=15, x1=15, y0=30, y1=70, lwd=2, length=0.15);
arrows(x0=30, x1=70, y0=85, y1=85, lwd=2, length=0.15);
arrows(x0=85, x1=85, y0=70, y1=30, lwd=2, length=0.15);
arrows(x0=70, x1=30, y0=15, y1=15, lwd=2, length=0.15);
arrows(x0=30, x1=36, y0=70, y1=65, lwd=2, length=0.075, code=3);
arrows(x0=65, x1=70, y0=65, y1=70, lwd=2, length=0.075, code=3);
text(x=50, y=90, labels="Policy", cex = 1.0);
text(x=50, y=20, labels="Monitoring", cex = 1.0);
text(x=10, y=48, labels="Indicators", srt=90, cex = 1.0);
text(x=90, y=52, labels="Actions", srt=-90, cex = 1.0);
```


Genetic Algorithm
---------------------------------------------------

Game theory is the formal study of strategic interactions, and can therefore be applied to modelling stakeholder actions and addressing issues of cooperation and conflict in conservation [@Colyvan2011; @Lee2012; @Kark2015; @Adami2016; @Tilman2016]. In game-theoretic models, agents adopt strategies to make decisions that maximise some type of payoff (e.g., utility, biological fitness). Agents are constrained in their decision-making, and realised pay-offs depend on decisions made by other agents. In simple models, it is often useful to assume that agents are perfectly rational decision-makers, then find optimal solutions for pay-off maximisation mathematically. But models that permit even moderately complex decision-making strategies or pay-off structures often include more possible strategies than are mathematically tractable [@Hamblin2013]. In these models, genetic algorithms, which mimic the process of natural selection (mutation, recombination, selection, reproduction), can find adaptive (i.e., practical, but not necessarily optimal) solutions for game strategies [e.g., @Balmann2000; @Tu2000; @Hamblin2013]. 

Consistent with the MSE approach [@Bunnefeld2011], GMSE does not attempt to find optimal strategies or solutions for agents (stakeholders). Instead, genetic algorithms are used to heuristically find an adaptive strategy for each stakeholder in each time step. Critically, all stakeholders involved in resource conservation are constrained in their decision-making; managing and using resources takes effort (e.g., time or money), and effort expended in developing or enforcing one policy (for managers) or performing one action (for users) will be effort not expendable elsewhere [@Milner-Gulland2011; @Muller-Hansen2017; @Schluter2017]. In finding strategies, GMSE models this trade-off by setting a fixed budget for managers and users. Allocations from a manager's budget can be used to increase the cost it takes a user to perform an action (i.e., 'policy'), and allocations from a user's budget can be used to perform the action at the cost set by the manager. Hence, stakeholders can have incomplete control over resource use and express competing management objectives.

In each new call of the genetic algorithm, a unique population of managers or users with random strategies is temporarily initialised. In each generation of the genetic algorithm, these strategies crossover and mutate; when this results in strategies that are over-budget, expenditures are iteratively decreased at random until budget constraints are satisfied. A fitness function then evaluates each strategy in the population, and a tournament is used to select the next generation of strategies [@Hamblin2013]. The genetic algorithm terminates when a minimum number of generations has passed and the increase in the fitness of the fittest strategy between the current and previous generation is below some threshold. The highest fitness strategy in the population then becomes the stakeholder's new strategy.


GMSE arguments and output
---------------------------------------------------

Simulations are run using the gmse() function, which offers a range of options for setting parameter values (see Table 1 for some select examples). Output of gmse() is an exhaustive list that includes all resources and observations, all stakeholder decisions and actions, and all landscape properties in each time step of the simulation. Results are most easily interpreted visually, so a summary of simulation dynamics is plotted by default (the plot can also be called using the plot_gmse_results function). An example below shows how simulations are set and interpreted.


|  Argument       | Default | Description                                                                                      |
|-----------------|---------|--------------------------------------------------------------------------------------------------|
|  time_max       |  100    | Maximum time steps in simulation                                                                 |
|  land_dim_1     |  100    | Width of the landscape (horizontal cells)                                                        |
|  land_dim_2     |  100    | Height of the landscape (vertical cells)                                                         |
|  res_movement   |  20     | Distance (cells) a resource can move in any direct (for movement rules, see res_move_type)       |
|  remove_pr      |  0      | Density-independent probability of resource mortality during a time step                         |
|  lambda         |  0.3    | Poisson rate parameter for resource offspring number produced during a time step                 |
|  agent_view     |  10     | How far managers can see on the landscape for resource counting when observe_type = 0            |
|  res_birth_K    |  10000  | Carrying capacity applied to the number of resources added during a time step                    |
|  res_death_K    |  600    | Carrying capacity applied to the number of resources removed during a time step                  |
|  res_move_type  |  1      | Type of resource movement (default is up to res_movement cells in any direction)                 |
|  observe_type   |  0      | Type of resource observation (default is density-based; i.e, counting a subset on the landscape) |
|  fixed_mark     |  50     | For mark-recapture observation (observe_type = 1), number of marked resources                    |
|  fixed_recapt   |  150    | For mark-recapture observation (observe_type = 1), number of recaptured resources                |
|  times_observe  |  8      | For density-based observation (observe_type = 0), landscape subsets viewed during observation    |
|  res_consume    |  0.5    | Proportion of a landscape cell's value reduced by the presence of a resource in a time step      |
|  max_ages       |  5      | The maximum number of time steps a resource can persist before it is removed                     |
|  minimum_cost   |  10     | The minimum cost of a stakeholder performing any action                                          |
|  user_budget    |  1000   | A stakeholder's budget per time step for performing any number of actions                        |
|  manager_budget |  1000   | A manager's budget per time step for setting policy                                              |
|  manage_target  |  300    | The manager's target resource abundance                                                          |
|  RESOURCE_ini   |  300    | The initial abundance of resources                                                               |
|  scaring        |  FALSE  | Resource scaring is a policy option                                                              |
|  culling        |  TRUE   | Resource culling is a policy option                                                              |
|  castration     |  FALSE  | Resource castration is a policy option                                                           |
|  feeding        |  FALSE  | Resource feeding (increases lambda) is a policy option                                           |
|  help_offspring |  FALSE  | Resource helping (increases offspring number) is a policy option                                 |
|  tend_crops     |  FALSE  | Stakeholders can increase landscape cell values                                                  |
|  tend_crop_yld  |  0.2    | Proportional increase per landscape cell from tend_crops action                                  |
|  kill_crops     |  FALSE  | Stakeholders can decrease landscape cell values to zero                                          |
|  stakeholders   |  4      | Number of stakeholders in the simulation                                                         |
|  land_ownership |  FALSE  | Stakeholders own land and increase utility indirectly from landscape instead of resource use     |
|  manage_freq    |  1      | Frequency (in time steps) with which managers revise and enact policy                            |
|  public_land    |  0      | Proportion of land that is public (un-owned by stakeholders) if land_ownership = TRUE            |

**Table 1:** Select parameter values for initialising generalised management strategy evaluation simulations


An example of resource management
===================================================

Here we consider the example of a managed natural resource whose abundance affects a group of stakeholders by temporarily decreasing the value of user land. This scenario could be interpreted in multiple ways; we consider a protected population of waterfowl that exploits agricultural land causing a conservation conflict with users [hereafter 'farmers', e.g., @Tuvendal2015; @Fox2016a; @Fox2017a]. Managers in this example might want to keep the abundance of waterfowl at a target level, while farmers might want to minimise the damage inflicted on their crops [e.g., @Madsen2017]. Using GMSE, it is possible to simulate waterfowl population dynamics, along with the continued monitoring and policy set by managers, and the actions that farmers take to protect their crop yields given the constraints of policy. We consider a population of waterfowl with an initial abundance and manager target abundance of 1000, but whose carrying capacity is 2000. Waterfowl consume and destroy all crop yield upon arrival to a landscape cell. In each time step, waterfowl are observed on subset of cells, then managers extrapolate from density per cell to estimate total population size. Managers then use these estimates to set costs of culling and scaring (non-lethal) waterfowl for 10 farmers. Farmers attempt to reduce the negative impact of waterfowl on the cropland that they own, working within the constraints of culling and scaring costs and their budget for performing these actions.

```{r, echo = TRUE}
sim <- gmse(land_ownership = TRUE, stakeholders = 10, observe_type = 0, 
            res_death_K = 2000, manage_target = 1000, RESOURCE_ini = 1000, 
            user_budget = 5000, manager_budget = 5000, res_consume = 1, 
            scaring = TRUE, times_observe = 1, plotting = FALSE);
```

Parameters in gmse() not listed are set to default values. By plotting the output with plot_gmse_results, simulation results can be interpreted visually.

```{r, eval = FALSE}
plot_gmse_results(res = sim$resource, obs = sim$observation, land = sim$land, 
                  agents = sim$agents, paras = sim$paras, ACTION = sim$action, 
                  COST = sim$cost);
```

```{r, echo = FALSE, fig.height = 6, fig.align = 'left', fig.cap = "Results of an example simulation illustrating the management of a protected resource that exploits the land of 10 stakeholders. The upper left panel shows locations of resources (black dots) on the landscape in the final time step of the simulation. The upper right panel shows the same landscape broken down into 10 differently coloured regions, which correspond to areas of land owned by each of the 10 stakeholders. The middle left panel shows the actual abundance of resources (black solid line, and the abundance of resources as estimated by the manager (blue solid line; shading indicates 95 percent confidence intervals of a mark-recapture analysis), over time. The horizontal dotted red and blue lines show the resource carrying capacity enacted on adult mortality and the manager's target for resource abundance, respectively. The orange line shows the total percent yield of landscape cells. The middle right panel shows total percent yield of landscape cells for each individual farmer, differentiated by colour, where line colours correspond to areas of the landscape in the upper right panel. The lower left panel shows the cost of stakeholders performing actions over time, as set by the manager. The lower right panel shows the total number of actions attempted to be performed by all stakeholders over time (some actions might be unsuccessful if resources are unavailable on a stakeholder's land to cull or scare, so, e.g., culling actions might be larger than resources actually culled)."}
plot_gmse_results_vign(res = sim$resource, obs = sim$observation, 
                       land = sim$land, agents = sim$agents, paras = sim$paras,
                       ACTION = sim$action, COST = sim$cost);
```

Figure 2 shows the landscape broken down by resource position and farmer land ownership in the upper left and right hand panels, respectively. The waterfowl population fluctuates around the manager's target size of 1000, but the manager's estimate of population size deviates from its actual size due to observation uncertainty (compare black and blue lines the middle left panel). Because the waterfowl have a direct negative effect on landscape yield, total landscape yield (orange line of the middle left panel), along with the yield of individual farmers (right middle panel), is low when waterfowl abundance is high, and vice versa.

Only the estimates of population size from the observation model are available to the manager, so policy change at any time step is driven primarily by the deviation of the currently estimated population size from the manager's target and the actions of farmers in the previous time step. Hence, when the population size is estimated to be below (above) the manager's target, the manager increases (decreases) the cost of culling and decreases (increases) the cost of scaring. Because the manager does not know in advance how stakeholders will react to policy change, they assume a proportional response in total actions with respect to a change in cost (e.g., doubling the cost of culling will decrease stakeholder culling by $1/2$). Farmers responding to policy are interested only in minimising waterfowl's exploitation of their crops, so they will either cull or scare to remove the waterfowl from their land, depending on which option is more effective (i.e., cheaper). This is reflected in the bottom left versus right panels of Figure 2; when managers decrease culling costs relative to scaring, farmers respond with more total culling, and vice versa. Farmer decisions then affect waterfowl distribution and abundance, impacting future crop yield and policy.


Future development
===================================================

The GMSE package is under continued development to include additional features that will be of interest to conservation biologists, managers, and the general public. Such features will include multiple (interacting) resource types and sub-types (e.g., structured populations), improved stakeholder decision-making and prediction based on multiple time steps of simulation history, incorporation of empirical data (e.g., landscape features), and a browser-based graphical user interface. Additionally, future versions of GMSE will allow software users to take the place of stakeholders in decision-making during simulations (replacing the genetic algorithm as desired), facilitating the collection of data to test sociological hypotheses and further improve the realism of the genetic algorithm (for a preliminary example of this, see the 'hunt' argument in the gmse() function). Code underlying GMSE is publicly available on GitHub < https://github.com/bradduthie/gmse > and highly modular, so GMSE model components (black boxes in Figure 1) can be developed freely and independently, then integrated into the broader GMSE framework. The GMSE R package is therefore a versatile and collaborative tool with widespread applications for adaptive resource management.

References
===================================================


